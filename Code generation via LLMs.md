# Применение LLM для автоматизации разработки кастомного софта

## 1\. Введение

В этой статье рассматривается подход к автоматизации разработки кастомного софта с помощью комбинации **детерминированных** и **недетерминированных** систем. Под детерминированными системами понимаются обычные скрипты и оркестрация процессов, которые гарантируют повторяемость и завершение задач. Под недетерминированными системами понимаются инструменты написания кода на базе LLM, такие как Codex и Cloud Code, которые обеспечивают креативность и генерацию нового кода. Материал статьи посвящён тому, как связать эти подходы для снижения ручного труда, снижения Effort-to-Market (ETM) и сохранения контроля над качеством.

## 2\. Термины

Ниже приведены термины которые Я предлагаю использовать в рамках этой статье чтоб понять именно философию и подход к использованию AI для создания программных продуктов. В других условиях следует подходить и определять термины по другому.

### Требования:

**Требования** \-  это все что пользователи ожидают от работы софта в рамках того функционала и той заявленной ценности который этот софт должен принести пользователям.

Бывают функциональные и нефункциональные а также явные и неявные. 

В этом смысле развитие и поддержка софта рассматриваются как процесс постоянных изменений в требованиях. 

Цикл выглядит так: меняются требования → меняется код до тех пор пока он не начнет удовлетворять новым требованиям → процесс повторяется до бесконечности. 

Ниже приведена матрица требований (2×2), которая сочетает явные и неявные с функциональными и нефункциональными:

|  | Функциональные | Нефункциональные |
| ----- | ----- | ----- |
| **Явные требования** | Прописанные User Stories, Epics, бизнес-правила. Пример: кнопка «Сохранить» сохраняет запись. | Задокументированные SLA. Пример: страница должна загружаться менее чем за 1 секунду. |
| **Неявные требования** | Стандарты, которые обычно не фиксируются в документах но все равно существуют. Пример: понятные сообщения об ошибках при логине, наличие лоадера при долгой операции | Общепринятые must-have. Например отсутствие возможности SQL инъекций, и возможность мониторинга системы в реальном времени. |

### Quality of Software: 

Первым параметром который важен для бизнеса \- это насколько софт соответствует ожиданиям пользователей. 

**Quality of Software** \- количество из всех требований в % выполняются. Это невозможно рассчитать абсолютно точно потому что существуют субъективные требования как, например, удобство. Тут используется фидбек.

| Что является качеством разрабатываемого софта | Что не является качеством разрабатываемого софта |
| :---- | :---- |
| Работа функционала согласно ожиданиям пользователя; ожидаемое поведение интерфейса; красота интерфейса; Удобство интерфейс; соблюдение стандартов безопасности; выполнение up-time по SLA, оптимальность частоты релизов | То каким способом этот софт разрабатывается. Это монолит или не монолит. Он использует CDN или нет, использует кеш или нет. Быстро он развивается или нет. |

### Effort-to-Market (ETM):

Вторым важным параметром для бизнеса является то и насколько дорого стоит внесение изменений и насколько это можно делать быстро.

**Effort-to-Market**  \- это количество усилий в виде времени, труда и денег, которые необходимо приложить для того, чтобы изменения в  требования были реализованы с нужным качеством.

### Quality of Code:

В рамках этой статьи (и это критически важно для использование AI эффективно) я предлагаю определять качество кода не по его внутренним характеристикам а по внешним бизнес параметрам **Quality of Software** и **Effort-to-Market**.

**Quality of Code** \- это то насколько данный код удовлетворяет требованиям сейчас и насколько быстро и дешево можно будет реализовать изменения в требованиях в будущем. 

| Что является Quality of Code | Что не является Quality of Code |
| :---- | :---- |
| Работа функционала согласно ожиданиям пользователя; ожидаемое поведение интерфейса; красота интерфейса; Удобство интерфейса; скорость и легкость внесения изменений, масштабируемость, скорость работы. | Использование паттернов программирование. Использование паттернов архитектуры. Структура папок и классов.  |

### Детерминированные и недетерминированные системы:

В автоматизации существуют два типа систем:  
**Детерминированная система** \- это система которая при одинаковых входящий параметрам всегда дает заранее определенный и предсказуемый результат. Основным свойством такой системы является то что она решает уже решенную 1 раз задачу постоянно и вариативность возможна то  
Исходя и задачи автоматизировать создание софта, надо также понимать что 

одинаковые входы → одинаковый выход; некреативна; логика задана заранее.

### Недетерминированная система (LLM):

результат зависит от контекста и случайности; креативна; слабо управляется «на лету».

### Эффективность разработки системы (LLM):

Я хочу подойти к эффективности системы как к тому что задача с использованием системы выполняется быстрее и с меньшими усилиями чем без нее.

## **3\. Постановка проблемы**

На текущий момент LLM научились создавать прототипы (Replit, Lovable, Codex Web) приложений однако мне еще не известно полноценное  использование LLM в долгосрочном повторяемои цикле развития и поддержки приложения.

Задача \- разработать систему в которой эффективность будет выше чем при классическом подходе к разработке софта. Т. е. Effort-to-market будет ниже при том же самом качестве.

* Разработка — повторяемые циклы, которые нужно надёжно доводить до конца и контролировать.  
* LLM генерирует большие объемы кода, ручная проверка масштабируется плохо и ведёт к пропускам.  
* Корректировки LLM «на ходу» часто проваливаются примерно в 50% случаев.  
* Нужен процесс, где детерминированная логика обеспечивает повторяемость и завершение, креатив локализован, ручной контроль минимален и сфокусирован, а задачи формулируются под результат за один проход.

## **4\. Решение**

Автоматизация разработки требует одновременно повторяемости и способности генерировать новое. Повторяемость обеспечивают детерминированные циклы, где порядок шагов и критерии завершения заданы кодом. Способность создавать новое даёт недетерминированная система (LLM), которая в нужных узлах подставляет креативное содержимое. Поэтому архитектурный принцип прост: детерминированная оркестрация управляет процессом от идеи до деплоя, а LLM включается только там, где нужна вариативность результата (формулировка user stories, проектирование интерфейсов, подбор реализаций, рефакторинг под ограничения).

Чтобы этот принцип давал предсказуемый результат, задачу для LLM нужно формулировать «под один проход». Модель плохо управляется в середине выполнения, поэтому корректировать её ответы по месту неэффективно. Следовательно, весь управляемый слой — подготовка контекста, структура промпта, формат ожидаемого ответа — должен быть зафиксирован заранее в детерминированном коде и шаблонах. Так мы переносим вариативность в строго отведённые точки и оставляем все циклы и проверки контролируемыми.

LLM лучше решает проблемы, чем конструирует решения с нуля, значит сначала нужно создать проверяемую «проблему». Эту роль выполняют end-to-end тесты. На первом шаге по спецификации формируются e2e‑тесты, описывающие поведение системы на уровне пользовательских сценариев. Эти тесты намеренно падают, потому что функция ещё не реализована. На втором шаге LLM меняет код, а не тесты, до тех пор, пока все тесты не пройдут. Так мы фиксируем критерий готовности заранее и исключаем «подгонку» проверки под реализацию.

Оркестрация всего процесса остаётся в детерминированном слое. Скрипты на TypeScript/Go управляют порядком шагов, извлекают контекст из репозитория и PR, генерируют промпты по шаблонам, вызывают LLM как CLI‑подпроцесс и фиксируют результаты. Это гарантирует завершение каждого цикла и воспроизводимость: если где‑то возникла ошибка, можно детерминированно откатить состояние (до удаления ветки/PR), скорректировать постановку задачи и запустить цикл заново с обновлённым контекстом.

После каждого прохода требуется ревью. Его цель — не править ответ LLM «по месту», а улучшить постановку задачи следующего запуска. Ревью может делать человек или другая LLM; замечания сохраняются, текущий результат отменяется, а затем в шаблоны и контекст добавляются выявленные условия, граничные случаи и форматные требования. Таким образом, каждая итерация повышает вероятность успеха «с первого раза» в следующем цикле.

Наконец, ручной контроль концентрируется не на сгенерированном коде, а на качестве e2e‑тестов. Это масштабируется: объём кода может расти на порядки, но слой пользовательских сценариев остаётся обозримым и управляемым. Если тесты корректны и полно покрывают требования, прохождение тестов служит объективным критерием «готово».

### **4.1 Оркестрация без API: детерминированные скрипты**

Временное решение: скрипты на TypeScript/JavaScript или Go вызывают Codex/Cloud Code как CLI‑подпроцессы.  
Эффект: контроль порядка шагов, гарантированное завершение циклов, использование готовых инструментов.

**Пример (PR):** прочитать все комментарии → итерироваться → для каждого вызвать LLM и классифицировать: фикс/тикет/игнор → выполнить действие. Промпты собираются шаблонизатором и насыщаются контекстом.

### **4.2 Инструменты**

* **Cloud Code** (\~$100/мес/чел): Opus/Sonnet, нет миллионного контекста; для 2–3 человек экономически сомнительно.  
* **Codex** (\~$40/мес): на базе ChatGPT‑5; встречаются лимиты на несколько дней.  
* **Cursor**: дорог (суммарно \~$1500 при активном использовании).  
  **Рекомендация:** VS Code \+ плагины Codex и Cloud Code; от Cursor отказаться.

## **5\. Метрики**

Система измеряется по трём независимым осям. Первая — **качество разрабатываемого софта** как процент соответствия явным и неявным, функциональным и нефункциональным требованиям. Эта метрика привязана к содержанию e2e‑тестов и их покрытию. Вторая — **Effort‑to‑Market (ETM)** как количество усилий в виде времени и труда, необходимых для реализации измененных требований. Она отражает, насколько быстро детерминированная оркестрация и шаблоны промптов позволяют переобучить процесс на новые условия при минимуме усилий. Третья — **качество кода** как совместная оценка двух предыдущих осей применительно к текущей реализации: достигаем ли мы нужного процента соответствия и с каким ETM возвращаемся к нему при изменениях.

Дополнительно фиксируется **доля однопроходных решений**. Этот показатель напрямую связан с качеством постановок и полнотой контекста: рост однопроходности означает, что ревью‑цикл правильно обучает шаблоны. Экономика замыкает систему метрик: **человеко‑часы на задачу** и **стоимость инструментов** дают простое сравнение с базовой линией «без LLM».

## **6\. Заключение**

Связка детерминированной оркестрации и точечных креативных вставок LLM даёт управляемость без потери новизны. «Один проход» достигается не за счёт давления на модель, а за счёт строгой подготовки: e2e‑тесты как закреплённая цель, шаблоны промптов как интерфейс, скрипты как источник воспроизводимости. Ревью переводится из правки результата в улучшение постановки на следующий цикл. В итоге повышается процент соответствия требованиям, снижается ETM, а качество кода оценивается объективно через эти две оси. Такой процесс масштабируется с ростом объёмов кода и сохраняет контроль там, где он действительно важен — на уровне пользовательских сценариев и усилий, необходимых для реакции на изменения.

